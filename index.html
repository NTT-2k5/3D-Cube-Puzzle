<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        .puzzle-grid-container {
            display: flex;
            flex-wrap: wrap;
            gap: 16px; /* Gap between layer tables */
            justify-content: center;
            align-items: flex-start;
            padding: 8px;
            overflow-x: auto;
            margin-bottom: 16px; /* Space before controls */
        }
        .puzzle-layer-table {
            border-collapse: collapse;
            border: 2px solid #6b7280; /* gray-500 */
            touch-action: none;
        }
        .puzzle-cell {
            width: 32px;
            height: 32px;
            min-width: 32px;
            border: 1px solid #d1d5db; /* gray-300 */
            position: relative;
            background-color: #f3f4f6; /* gray-100 - empty color */
            cursor: pointer;
            user-select: none;
        }
        .cell-depth-outer-ring, .cell-depth-inner-fill {
            position: absolute;
            box-sizing: border-box;
        }
        .cell-depth-outer-ring { /* This will be the border */
            width: 100%;
            height: 100%;
            border: 3px solid transparent; /* Thicker border for visual effect */
            left: 0;
            top: 0;
        }
        .cell-depth-inner-fill { /* This will be the background fill */
            width: calc(100% - 10px); /* Make inner fill smaller to show outer ring's border more */
            height: calc(100% - 10px);
            left: 5px;
            top: 5px;
        }
        .piece-palette-wrapper {
            width: 100%;
            margin-top: 16px;
            padding: 8px;
            background-color: #e5e7eb; /* gray-200 */
            border-radius: 8px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
        }
        .piece-palette {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            min-height: 60px;
            background-color: transparent;
            border-radius: 6px;
            justify-content: center;
            overflow-x: auto;
        }
        .piece-representation {
            width: auto;
            height: auto;
            padding: 4px;
            border: 2px solid #9ca3af; /* gray-400 */
            background-color: #fff;
            cursor: grab;
            display: grid;
            gap: 1px;
            border-radius: 4px;
        }
        .piece-representation.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }
        .piece-block-mini {
            width: 8px;
            height: 8px;
        }
        .piece-block-ghost {
            opacity: 0.5;
        }
        .message-box {
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            text-align: center;
            font-weight: 500;
        }
        .message-success {
            background-color: #d1fae5; /* green-100 */
            color: #065f46; /* green-800 */
        }
        .message-error {
            background-color: #fee2e2; /* red-100 */
            color: #991b1b; /* red-800 */
        }
        .highlight-valid {
            outline: 2.4px dashed #22c55e; /* green-500 */
            outline-offset: -2px;
        }
        .highlight-invalid {
            outline: 2.4px dashed #ef4444; /* red-500 */
            outline-offset: -2px;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            max-width: 100vw;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 antialiased select-none">

    <div class="main-content container mx-auto p-2 md:p-4">
        <header class="text-center mb-4">
            <h1 class="text-2xl md:text-3xl font-bold text-blue-600">3D Cube Puzzle</h1>
        </header>

        <div class="size-selector mb-3 text-center">
            <label for="puzzle-size-selector" class="mr-2 font-medium">Puzzle Size:</label>
            <select id="puzzle-size-selector" class="border border-gray-300 rounded-md p-1 md:p-2 shadow-sm focus:ring-blue-500 focus:border-blue-500">
                <option value="3">3x3x3</option>
                <option value="4">4x4x4</option>
                <option value="5">5x5x5</option>
            </select>
            <button id="new-game-button" class="ml-2 py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-blue-500 hover:bg-blue-600 transition-colors duration-150">New Game</button>
            <button id="restart-button" class="ml-2 py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-blue-500 hover:bg-blue-600 transition-colors duration-150">Restart</button>
        </div>

        <div class="game-area">
            <div id="puzzle-grid-container" class="puzzle-grid-container bg-white shadow-lg rounded-lg p-1 md:p-2">
                {/* Puzzle layers (tables) will be generated here */}
            </div>

            <div class="controls-container flex flex-col items-center gap-1 md:gap-2 mb-3 p-2 bg-gray-200 rounded-md">
                <div class="flex flex-wrap justify-center gap-1 md:gap-2"> <button id="rotate-x-button" title="Rotate X (X)" class="py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-blue-500 hover:bg-blue-600 transition-colors duration-150">Rotate X</button>
                    <button id="rotate-y-button" title="Rotate Y (Y)" class="py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-blue-500 hover:bg-blue-600 transition-colors duration-150">Rotate Y</button>
                    <button id="rotate-z-button" title="Rotate Z (Z)" class="py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-blue-500 hover:bg-blue-600 transition-colors duration-150">Rotate Z</button>
                </div>
                <div class="flex flex-wrap justify-center gap-1 md:gap-2"> <button id="confirm-placement-button" title="Confirm Placement (Enter)" class="py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-green-500 hover:bg-green-600 transition-colors duration-150">Place ✔</button>
                    <button id="deselect-button" title="Deselect Piece (Escape)" class="py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-red-500 hover:bg-red-600 transition-colors duration-150">Deselect</button>
                    <button id="return-piece-button" title="Return Piece to Tray (T)" class="py-1 px-3 md:py-2 md:px-4 rounded-md font-medium text-white bg-yellow-500 hover:bg-yellow-600 transition-colors duration-150" style="display: none;">Return Piece</button>
                </div>
            </div>
        </div>

        <div class="piece-palette-wrapper">
            <h2 class="text-lg md:text-xl font-semibold mb-1 text-center">Available Pieces</h2>
            <div id="piece-palette-container" class="piece-palette">
                {/* Draggable pieces will be generated here */}
            </div>
        </div>

        <div id="message-area" class="message-box mt-3" role="alert">
            Select a puzzle size and start a new game!
        </div>
    </div>

    <script>
        // --- Global Game State ---
        let puzzleSize = 3;
        let puzzleGrid = [];
        let solutionGrid = [];
        let gamePieces = [];
        let availablePieces = [];
        let pieceIdCounter; // Initialized in newGame

        let selectedPiece = null;
        let draggedPieceElement = null;
        let draggedPieceData = null;

        let ghostCells = [];

        // --- DOM Elements ---
        const puzzleGridContainer = document.getElementById('puzzle-grid-container');
        const piecePaletteContainer = document.getElementById('piece-palette-container');
        const messageArea = document.getElementById('message-area');
        const puzzleSizeSelector = document.getElementById('puzzle-size-selector');
        const newGameButton = document.getElementById('new-game-button');
        const restartButton = document.getElementById('restart-button');
        const returnPieceButton = document.getElementById('return-piece-button');


        // --- Constants ---
        const COLORS = ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#0ea5e9', '#6366f1', '#a855f7', '#ec4899'];
        const EMPTY_CELL_COLOR = '#f3f4f6';
        const GHOST_COLOR = 'rgba(100, 116, 139, 0.5)';

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            newGameButton.addEventListener('click', initializeNewGame);
            restartButton.addEventListener('click', handleRestartPuzzle);
            returnPieceButton.addEventListener('click', handleReturnSelectedPieceToTray);
            puzzleSizeSelector.addEventListener('change', initializeNewGame);

            document.getElementById('rotate-x-button').addEventListener('click', () => rotateSelectedPiece('x'));
            document.getElementById('rotate-y-button').addEventListener('click', () => rotateSelectedPiece('y'));
            document.getElementById('rotate-z-button').addEventListener('click', () => rotateSelectedPiece('z'));
            document.getElementById('deselect-button').addEventListener('click', deselectPiece);
            document.getElementById('confirm-placement-button').addEventListener('click', confirmPiecePlacement);

            document.addEventListener('keydown', handleKeyPress);
            initializeNewGame();
        });

        function initializeNewGame() {
            puzzleSize = parseInt(puzzleSizeSelector.value);
            selectedPiece = null;
            draggedPieceElement = null;
            draggedPieceData = null;
            ghostCells = [];
            pieceIdCounter = 1;

            showMessage(`Generating new ${puzzleSize}x${puzzleSize}x${puzzleSize} puzzle...`, 'info');

            const generationResult = generateSolvablePuzzle(puzzleSize);
            if (!generationResult) {
                showMessage('Failed to generate a solvable puzzle. Please try again.', 'error');
                puzzleGrid = createEmptyGrid(puzzleSize);
                gamePieces = [];
                availablePieces = [];
                renderPuzzleGrid();
                renderPiecePalette();
                updateButtonStates();
                return;
            }

            puzzleGrid = createEmptyGrid(puzzleSize);
            solutionGrid = generationResult.solvedGrid;

            gamePieces = generationResult.gamePieces.map(p => {
                const { optimalShapeCoords, optimalRotationMatrix } = getOptimalPreviewOrientation(p.shape);
                return {
                    ...p, // Contains id, shape (base), color, numBlocks, solutionPosition, solutionRotation
                    placed: false,
                    currentRotationMatrix: optimalRotationMatrix,
                    initialRotationMatrix: optimalRotationMatrix, // Store initial orientation
                    positionOnBoard: null,
                    currentShapeCoords: optimalShapeCoords,
                    previewPosition: { x: 0, y: 0, z: 0 }
                    // justPickedUpFromBoard will be set on selectedPiece dynamically
                };
            });

            const fillerPieces = addFillerPieces(solutionGrid, pieceIdCounter, gamePieces.length % COLORS.length);
            gamePieces.push(...fillerPieces);
            availablePieces = [...gamePieces];

            renderPuzzleGrid();
            renderPiecePalette();
            updateButtonStates();
            if (gamePieces.length > 0) {
                const totalVolume = puzzleSize * puzzleSize * puzzleSize;
                const numOriginalPieces = generationResult.gamePieces.length;
                const numFillerPieces = fillerPieces.length;
                showMessage(`Puzzle ready! ${numOriginalPieces} main pieces, ${numFillerPieces} filler pieces. Total: ${gamePieces.length}. Fill ${totalVolume} cells.`, 'success');
            } else {
                showMessage('No pieces generated. Puzzle generation might need adjustment.', 'error');
            }
        }

        // --- Grid and Piece Logic ---
        function createEmptyGrid(size) {
            const grid = [];
            for (let z = 0; z < size; z++) {
                const layer = [];
                for (let y = 0; y < size; y++) {
                    layer.push(new Array(size).fill(0));
                }
                grid.push(layer);
            }
            return grid;
        }

        function generateSolvablePuzzle(size) {
            // pieceIdCounter is global
            let tempGrid = createEmptyGrid(size);
            let pieces = [];
            let filledCellsCount = 0;
            const totalCells = size * size * size;
            let attempts = 0;
            const maxAttempts = totalCells * 5;

            let targetBlocks = [];
            let currentBlockSum = 0;
            while(currentBlockSum < totalCells) {
                let nextBlockSize = (Math.random() < 0.6 || totalCells - currentBlockSum === 4) ? 4 : 5;
                if (currentBlockSum + nextBlockSize > totalCells) {
                    if (totalCells - currentBlockSum >= 4 && totalCells - currentBlockSum <= 5) {
                        nextBlockSize = totalCells - currentBlockSum;
                    } else {
                        break;
                    }
                }
                targetBlocks.push(nextBlockSize);
                currentBlockSum += nextBlockSize;
            }
            if (currentBlockSum !== totalCells && targetBlocks.length > 0) {
                let remaining = totalCells - (currentBlockSum - targetBlocks[targetBlocks.length-1]);
                if (remaining >= 4 && remaining <= 5) targetBlocks[targetBlocks.length-1] = remaining;
                else targetBlocks = [];
            }

            let blockQueue = [...targetBlocks];

            while (filledCellsCount < totalCells && attempts < maxAttempts) {
                attempts++;
                let numBlocks;
                if (blockQueue.length > 0) {
                    numBlocks = blockQueue.shift();
                } else {
                    if (totalCells - filledCellsCount >= 5) numBlocks = (Math.random() < 0.6) ? 4 : 5;
                    else if (totalCells - filledCellsCount === 4) numBlocks = 4;
                    else break;
                }

                if (!numBlocks || filledCellsCount + numBlocks > totalCells) continue;

                const pieceShape = generateRandomPieceShape(numBlocks, size); // pieceShape is normalized here
                if (!pieceShape) continue;

                const possiblePlacements = [];
                const rotations = getAllRotations();

                for (let z_coord = 0; z_coord < size; z_coord++) {
                    for (let y_coord = 0; y_coord < size; y_coord++) {
                        for (let x_coord = 0; x_coord < size; x_coord++) {
                            if (tempGrid[z_coord][y_coord][x_coord] === 0) {
                                for (const rotMatrix of rotations) {
                                    const transformedShape = transformShape(pieceShape, rotMatrix); // Not re-normalized here for placement check
                                    const placementResult = checkPlacement(tempGrid, transformedShape, {x: x_coord, y: y_coord, z: z_coord}, size);
                                    if (placementResult.fits) {
                                        possiblePlacements.push({
                                            shape: pieceShape, // base shape
                                            transformedShape: transformedShape,
                                            position: {x: x_coord, y: y_coord, z: z_coord},
                                            rotationMatrix: rotMatrix,
                                            cells: placementResult.cellsToOccupy
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                if (possiblePlacements.length > 0) {
                    const chosenPlacement = possiblePlacements[Math.floor(Math.random() * possiblePlacements.length)];
                    const newPiece = {
                        id: pieceIdCounter++,
                        shape: chosenPlacement.shape, // Store the base, normalized shape
                        color: COLORS[(pieceIdCounter - 2) % COLORS.length],
                        numBlocks: numBlocks,
                        solutionPosition: chosenPlacement.position,
                        solutionRotation: chosenPlacement.rotationMatrix // This is the rotation for the solution
                    };
                    pieces.push(newPiece);
                    chosenPlacement.cells.forEach(cell => {
                        tempGrid[cell.z][cell.y][cell.x] = newPiece.id;
                    });
                    filledCellsCount += numBlocks;
                } else {
                    if (numBlocks) blockQueue.unshift(numBlocks);
                }
            }

            if (filledCellsCount < totalCells) {
                 console.warn(`Puzzle generation incomplete: ${filledCellsCount}/${totalCells} cells filled by main pieces. Fillers will be added.`);
                 if (pieces.length === 0 && totalCells > 0) {
                    console.error("No main pieces generated. Fillers will attempt to fill the cube.");
                 }
                 const currentPieces = [...pieces];
                 tempGrid = createEmptyGrid(size);
                 filledCellsCount = 0;
                 pieces = [];
                 currentPieces.forEach(p => {
                    const transformedShape = transformShape(p.shape, p.solutionRotation);
                    const placement = checkPlacement(tempGrid, transformedShape, p.solutionPosition, size);
                    if(placement.fits){
                        placement.cellsToOccupy.forEach(cell => {
                            tempGrid[cell.z][cell.y][cell.x] = p.id;
                        });
                        filledCellsCount += p.numBlocks;
                        pieces.push(p);
                    } else {
                        console.error("Error re-placing piece for solution grid. Piece ID:", p.id);
                    }
                 });
                 if (filledCellsCount === 0 && currentPieces.length > 0) {
                    console.warn("All main pieces failed to re-place in solution grid. Fillers will attempt to fill.");
                 }
            }
            return { solvedGrid: tempGrid, gamePieces: pieces };
        }

        function createFillerPieceEntry(id, shape, colorIdx) {
            const { optimalShapeCoords, optimalRotationMatrix } = getOptimalPreviewOrientation(shape);
            return {
                id: id,
                shape: shape, // base shape
                color: COLORS[colorIdx % COLORS.length],
                numBlocks: shape.length,
                placed: false,
                currentRotationMatrix: optimalRotationMatrix,
                initialRotationMatrix: optimalRotationMatrix,
                positionOnBoard: null,
                currentShapeCoords: optimalShapeCoords,
                previewPosition: { x: 0, y: 0, z: 0 },
                isFiller: true
            };
        }

        function addFillerPieces(solutionGridFromGenerator, startingPieceId, startingColorIndex) {
            const newFillerPieces = [];
            const size = solutionGridFromGenerator.length;
            const processedForFiller = createEmptyGrid(size);

            let currentPieceId = startingPieceId;
            let currentColorIndex = startingColorIndex;

            for (let z = 0; z < size; z++) {
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        if (solutionGridFromGenerator[z][y][x] === 0 && processedForFiller[z][y][x] === 0) {
                            let pieceShape = null;
                            let cellsToMarkCoords = [];

                            if (x + 1 < size && solutionGridFromGenerator[z][y][x+1] === 0 && processedForFiller[z][y][x+1] === 0) {
                                pieceShape = [[0,0,0], [1,0,0]];
                                cellsToMarkCoords.push({z,y,x}, {z,y,x:x+1});
                            }
                            else if (y + 1 < size && solutionGridFromGenerator[z][y+1][x] === 0 && processedForFiller[z][y+1][x] === 0) {
                                pieceShape = [[0,0,0], [0,1,0]];
                                cellsToMarkCoords.push({z,y,x}, {z,y:y+1,x});
                            }
                            else if (z + 1 < size && solutionGridFromGenerator[z+1][y][x] === 0 && processedForFiller[z+1][y][x] === 0) {
                                pieceShape = [[0,0,0], [0,0,1]];
                                cellsToMarkCoords.push({z,y,x}, {z:z+1,y,x});
                            }

                            if (!pieceShape) {
                                pieceShape = [[0,0,0]];
                                cellsToMarkCoords.push({z,y,x});
                            }

                            const newPiece = createFillerPieceEntry(currentPieceId, pieceShape, currentColorIndex);
                            newFillerPieces.push(newPiece);

                            cellsToMarkCoords.forEach(coord => {
                                processedForFiller[coord.z][coord.y][coord.x] = 1;
                            });

                            currentPieceId++;
                            currentColorIndex = (currentColorIndex + 1) % COLORS.length;
                        }
                    }
                }
            }
            pieceIdCounter = currentPieceId;
            return newFillerPieces;
        }


        function generateRandomPieceShape(numBlocks, puzzleDim) {
            let shape = [[0,0,0]]; // Start with one block at origin
            const DIRS = [ [0,0,1], [0,0,-1], [0,1,0], [0,-1,0], [1,0,0], [-1,0,0] ];
            let attempts = 0;

            while (shape.length < numBlocks && attempts < 50) {
                attempts++;
                const originBlockIndex = Math.floor(Math.random() * shape.length);
                const originBlock = shape[originBlockIndex];
                const dirIndex = Math.floor(Math.random() * DIRS.length);
                const dir = DIRS[dirIndex];
                const newBlock = [originBlock[0] + dir[0], originBlock[1] + dir[1], originBlock[2] + dir[2]];

                // Check if block already exists
                if (!shape.some(b => b[0] === newBlock[0] && b[1] === newBlock[1] && b[2] === newBlock[2])) {
                    // Check if new block creates too large a piece dimensionally
                    let tempShapeForCheck = [...shape, newBlock];
                    let min_coord = [Infinity,Infinity,Infinity], max_coord = [-Infinity,-Infinity,-Infinity];
                    tempShapeForCheck.forEach(b_coord => {
                        min_coord[0] = Math.min(min_coord[0], b_coord[0]); max_coord[0] = Math.max(max_coord[0], b_coord[0]);
                        min_coord[1] = Math.min(min_coord[1], b_coord[1]); max_coord[1] = Math.max(max_coord[1], b_coord[1]);
                        min_coord[2] = Math.min(min_coord[2], b_coord[2]); max_coord[2] = Math.max(max_coord[2], b_coord[2]);
                    });
                     // Max dimension of a piece usually shouldn't exceed puzzleDim or a reasonable limit like 4
                    if (max_coord[0]-min_coord[0] < Math.min(4, puzzleDim) &&
                        max_coord[1]-min_coord[1] < Math.min(4, puzzleDim) &&
                        max_coord[2]-min_coord[2] < Math.min(4, puzzleDim)) {
                         shape.push(newBlock);
                         attempts = 0; // Reset attempts on successful addition
                    }
                }
            }

            if (shape.length < numBlocks) return null; // Failed to generate a valid shape

            // Normalize the shape so that its minimum coordinates are (0,0,0)
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            shape.forEach(b => {
                minX = Math.min(minX, b[0]);
                minY = Math.min(minY, b[1]);
                minZ = Math.min(minZ, b[2]);
            });
            return shape.map(b => [b[0] - minX, b[1] - minY, b[2] - minZ]);
        }


        function getOptimalPreviewOrientation(baseShape) {
            const allPossibleRotations = getAllRotations();
            let bestOrientation = null;
            let maxBlocksAtZ0 = -1;
            // Tie-breaking stats for the bestOrientation found so far
            let bestMaxZ = Infinity;
            let bestMaxX = Infinity;
            let bestMaxY = Infinity;

            for (const rotMatrix of allPossibleRotations) {
                let rotatedShape = transformShape(baseShape, rotMatrix);

                let minX_rot = Infinity, minY_rot = Infinity, minZ_rot = Infinity;
                rotatedShape.forEach(p => {
                    minX_rot = Math.min(minX_rot, p[0]);
                    minY_rot = Math.min(minY_rot, p[1]);
                    minZ_rot = Math.min(minZ_rot, p[2]);
                });

                const normalizedShape = rotatedShape.map(p => [p[0] - minX_rot, p[1] - minY_rot, p[2] - minZ_rot]);

                let currentBlocksAtZ0 = 0;
                let currentMaxX_norm = 0, currentMaxY_norm = 0, currentMaxZ_norm = 0;
                normalizedShape.forEach(p => {
                    if (p[2] === 0) {
                        currentBlocksAtZ0++;
                    }
                    currentMaxX_norm = Math.max(currentMaxX_norm, p[0]);
                    currentMaxY_norm = Math.max(currentMaxY_norm, p[1]);
                    currentMaxZ_norm = Math.max(currentMaxZ_norm, p[2]);
                });

                // Determine if this orientation is better
                let isBetter = false;
                if (bestOrientation === null) {
                    isBetter = true;
                } else if (currentBlocksAtZ0 > maxBlocksAtZ0) {
                    isBetter = true;
                } else if (currentBlocksAtZ0 === maxBlocksAtZ0) {
                    if (currentMaxZ_norm < bestMaxZ) {
                        isBetter = true;
                    } else if (currentMaxZ_norm === bestMaxZ) {
                        if (currentMaxX_norm < bestMaxX) {
                            isBetter = true;
                        } else if (currentMaxX_norm === bestMaxX) {
                            if (currentMaxY_norm < bestMaxY) {
                                isBetter = true;
                            }
                        }
                    }
                }

                if (isBetter) {
                    maxBlocksAtZ0 = currentBlocksAtZ0;
                    bestMaxZ = currentMaxZ_norm;
                    bestMaxX = currentMaxX_norm;
                    bestMaxY = currentMaxY_norm;
                    bestOrientation = {
                        optimalShapeCoords: normalizedShape,
                        optimalRotationMatrix: rotMatrix
                    };
                }
            }

            if (!bestOrientation) { // Fallback, should ideally not be reached
                console.warn("Could not find optimal preview orientation. Defaulting.");
                let minX_base = Infinity, minY_base = Infinity, minZ_base = Infinity;
                baseShape.forEach(p => { minX_base = Math.min(minX_base, p[0]); minY_base = Math.min(minY_base, p[1]); minZ_base = Math.min(minZ_base, p[2]); });
                const normalizedBaseShape = baseShape.map(p => [p[0] - minX_base, p[1] - minY_base, p[2] - minZ_base]);
                return {
                    optimalShapeCoords: normalizedBaseShape,
                    optimalRotationMatrix: identityMatrix()
                };
            }
            return bestOrientation;
        }


        function checkPlacement(grid, pieceCoords, position, gridSize) {
            const cellsToOccupy = [];
            for (const pCoord of pieceCoords) {
                const absX = position.x + pCoord[0];
                const absY = position.y + pCoord[1];
                const absZ = position.z + pCoord[2];

                if (absX < 0 || absX >= gridSize || absY < 0 || absY >= gridSize || absZ < 0 || absZ >= gridSize) {
                    return { fits: false, reason: 'out_of_bounds' };
                }
                if (grid[absZ][absY][absX] !== 0) {
                    return { fits: false, reason: 'overlap' };
                }
                cellsToOccupy.push({ x: absX, y: absY, z: absZ });
            }
            return { fits: true, cellsToOccupy };
        }

        // --- Rendering ---
        function renderPuzzleGrid() {
            puzzleGridContainer.innerHTML = '';
            clearGhostPreview();

            for (let z = 0; z < puzzleSize; z++) {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'puzzle-layer text-xs md:text-sm';
                layerDiv.innerHTML = `<h3 class="font-semibold text-center mb-1">Layer ${z + 1}</h3>`;

                const table = document.createElement('table');
                table.className = 'puzzle-layer-table mx-auto';
                table.dataset.zIndex = z;

                for (let y = 0; y < puzzleSize; y++) {
                    const row = table.insertRow();
                    for (let x = 0; x < puzzleSize; x++) {
                        const cell = row.insertCell();
                        cell.className = 'puzzle-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        cell.dataset.z = z;

                        const outerRing = document.createElement('div');
                        outerRing.className = 'cell-depth-outer-ring';
                        const innerFill = document.createElement('div');
                        innerFill.className = 'cell-depth-inner-fill';

                        const pieceId = puzzleGrid[z][y][x];
                        let cellColor = EMPTY_CELL_COLOR;
                        let borderColor = 'transparent';

                        if (pieceId !== 0) {
                            const piece = gamePieces.find(p => p.id === pieceId);
                            if (piece) {
                                cellColor = piece.color;
                                borderColor = piece.color;
                            }
                        }

                        innerFill.style.backgroundColor = cellColor;
                        outerRing.style.borderColor = borderColor;

                        if (selectedPiece && !selectedPiece.placed && selectedPiece.previewPosition) {
                            const sp = selectedPiece;
                            const transformedShape = sp.currentShapeCoords; // These are already normalized
                            const previewPos = sp.previewPosition;
                            for (const pCoord of transformedShape) { // pCoord are relative to piece's (0,0,0)
                                if (previewPos.x + pCoord[0] === x && previewPos.y + pCoord[1] === y && previewPos.z + pCoord[2] === z) {
                                    innerFill.style.backgroundColor = GHOST_COLOR;
                                    outerRing.style.borderColor = GHOST_COLOR;
                                    cell.classList.add('piece-block-ghost');
                                    ghostCells.push(cell);
                                    break;
                                }
                            }
                        }
                        cell.appendChild(outerRing);
                        cell.appendChild(innerFill);
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('dragleave', handleDragLeave);
                        cell.addEventListener('drop', handleDrop);
                        cell.addEventListener('click', () => handleClickOnCell(x,y,z));
                    }
                }
                layerDiv.appendChild(table);
                puzzleGridContainer.appendChild(layerDiv);
            }
        }

        function renderPiecePalette() {
            piecePaletteContainer.innerHTML = '';
            availablePieces.forEach(piece => {
                if (piece.placed) return;

                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'piece-representation';
                pieceDiv.draggable = true;
                pieceDiv.dataset.pieceId = piece.id;

                // piece.currentShapeCoords are already normalized (min x,y,z are 0)
                let maxX = 0, maxY = 0;
                piece.currentShapeCoords.forEach(p => {
                    maxX = Math.max(maxX, p[0]);
                    maxY = Math.max(maxY, p[1]);
                });

                const cols = maxX + 1;
                const rows = maxY + 1;
                pieceDiv.style.gridTemplateColumns = `repeat(${cols}, 8px)`;
                pieceDiv.style.gridTemplateRows = `repeat(${rows}, 8px)`;

                const displayGrid = Array(rows).fill(null).map(() => Array(cols).fill(false));
                piece.currentShapeCoords.forEach(p => {
                    // p[0] and p[1] are x and y relative to piece's own origin (which is 0,0 due to normalization)
                    // We only care about the 2D projection for the palette, typically blocks with smallest z.
                    // For simplicity, we project all blocks; deeper blocks will overlap.
                    // A better palette might show blocks with local z=0 from currentShapeCoords.
                    if (p[0] < cols && p[1] < rows) { // Check bounds just in case
                         displayGrid[p[1]][p[0]] = true; // p[1] is row (y), p[0] is col (x)
                    }
                });

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const blockMini = document.createElement('div');
                        blockMini.className = 'piece-block-mini';
                        if (displayGrid[r][c]) { blockMini.style.backgroundColor = piece.color; }
                        pieceDiv.appendChild(blockMini);
                    }
                }
                pieceDiv.addEventListener('dragstart', handleDragStart);
                pieceDiv.addEventListener('dragend', handleDragEnd);
                pieceDiv.addEventListener('click', () => selectPieceById(piece.id, pieceDiv));
                if (selectedPiece && selectedPiece.id === piece.id) {
                    pieceDiv.classList.add('ring-2', 'ring-blue-500', 'ring-offset-1');
                }
                piecePaletteContainer.appendChild(pieceDiv);
            });
        }

        function clearGhostPreview() {
            ghostCells.forEach(cell => {
                const innerFill = cell.querySelector('.cell-depth-inner-fill');
                const outerRing = cell.querySelector('.cell-depth-outer-ring');
                const z = parseInt(cell.dataset.z);
                const y = parseInt(cell.dataset.y);
                const x = parseInt(cell.dataset.x);

                if(isNaN(x) || isNaN(y) || isNaN(z)) return; // Skip if cell data is invalid

                const pieceId = puzzleGrid[z][y][x];
                let cellColor = EMPTY_CELL_COLOR;
                let borderColor = 'transparent';
                if (pieceId !== 0) {
                    const piece = gamePieces.find(p => p.id === pieceId);
                    if (piece) { cellColor = piece.color; borderColor = piece.color; }
                }
                if(innerFill) innerFill.style.backgroundColor = cellColor;
                if(outerRing) outerRing.style.borderColor = borderColor;

                cell.classList.remove('piece-block-ghost', 'highlight-valid', 'highlight-invalid');
            });
            ghostCells = [];
        }


        function updateGhostPreview(targetCell = null) {
            clearGhostPreview();
            renderPuzzleGrid(); // This will draw the ghost based on selectedPiece properties

            if (!selectedPiece || selectedPiece.placed) return;

            let previewPos = selectedPiece.previewPosition;
            if (targetCell) {
                previewPos = { x: parseInt(targetCell.dataset.x), y: parseInt(targetCell.dataset.y), z: parseInt(targetCell.dataset.z) };
                selectedPiece.previewPosition = previewPos;
            } else if (!previewPos) {
                 selectedPiece.previewPosition = {x:0, y:0, z:0};
                 previewPos = selectedPiece.previewPosition;
            }

            const anchorCellElement = document.querySelector(`.puzzle-cell[data-x="${previewPos.x}"][data-y="${previewPos.y}"][data-z="${previewPos.z}"]`);
            if (anchorCellElement) {
                // Check placement using currentShapeCoords, which are normalized.
                const placement = checkPlacement(puzzleGrid, selectedPiece.currentShapeCoords, previewPos, puzzleSize);
                anchorCellElement.classList.add(placement.fits ? 'highlight-valid' : 'highlight-invalid');
                ghostCells.push(anchorCellElement);
            }
        }


        // --- Interaction Handlers ---
        function handleDragStart(event) {
            const pieceId = parseInt(event.target.dataset.pieceId);
            const piece = gamePieces.find(p => p.id === pieceId);
            if (piece && !piece.placed) {
                draggedPieceData = piece;
                event.dataTransfer.setData('text/plain', piece.id);
                event.dataTransfer.effectAllowed = 'move';
                event.target.classList.add('dragging');
                draggedPieceElement = event.target;
                selectPieceById(piece.id, event.target);
            } else {
                event.preventDefault();
            }
        }

        function handleDragEnd(event) {
            if (draggedPieceElement) {
                draggedPieceElement.classList.remove('dragging');
            }
            draggedPieceElement = null;
            draggedPieceData = null;
            if (selectedPiece && !selectedPiece.placed) {
                updateGhostPreview();
            } else {
                clearGhostPreview();
                renderPuzzleGrid();
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const cell = event.target.closest('.puzzle-cell');
            if (cell && selectedPiece && !selectedPiece.placed) {
                updateGhostPreview(cell);
            }
        }

        function handleDragLeave(event) {
            const cell = event.target.closest('.puzzle-cell');
            if (cell) {
                cell.classList.remove('highlight-valid', 'highlight-invalid');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            const targetCell = event.target.closest('.puzzle-cell');
            if (targetCell) targetCell.classList.remove('highlight-valid', 'highlight-invalid');

            if (!targetCell || !draggedPieceData) return;

            const piece = selectedPiece;

            if (piece && !piece.placed) {
                const targetX = parseInt(targetCell.dataset.x);
                const targetY = parseInt(targetCell.dataset.y);
                const targetZ = parseInt(targetCell.dataset.z);
                const targetPosition = { x: targetX, y: targetY, z: targetZ };
                piece.previewPosition = targetPosition;

                updateGhostPreview(targetCell);
                showMessage(`Piece previewed at ${targetX},${targetY},${targetZ}. Confirm to place.`, 'info');
            }
        }

        function handleClickOnCell(x,y,z){
            if (selectedPiece && !selectedPiece.placed) {
                const targetPosition = {x,y,z};
                selectedPiece.previewPosition = targetPosition;
                if (selectedPiece.justPickedUpFromBoard) {
                    selectedPiece.justPickedUpFromBoard = false;
                }
                updateGhostPreview(document.querySelector(`.puzzle-cell[data-x="${x}"][data-y="${y}"][data-z="${z}"]`));
                showMessage(`Previewing at ${x},${y},${z}. Use 'Place ✔' or controls.`, 'info');
            } else {
                const pieceIdAtCell = puzzleGrid[z][y][x];
                if (pieceIdAtCell !== 0) {
                    const piece = gamePieces.find(p => p.id === pieceIdAtCell);
                    if (piece && piece.placed) {
                        const lastBoardPos = {...piece.positionOnBoard}; // Store before removing
                        removePieceFromGrid(piece);
                        selectPieceById(piece.id, null);

                        if (selectedPiece) {
                            selectedPiece.justPickedUpFromBoard = true;
                            selectedPiece.previewPosition = lastBoardPos; // Set preview to its last board position
                            // piece.positionOnBoard is already nulled by removePieceFromGrid if desired,
                            // but here we use lastBoardPos for preview.
                        }
                        updateGhostPreview();
                        showMessage(`Piece ${piece.id} picked up. Move, rotate, place, or return to tray.`, 'info');
                    }
                } else {
                    if(selectedPiece && selectedPiece.justPickedUpFromBoard) {
                         selectedPiece.justPickedUpFromBoard = false;
                    }
                    deselectPiece();
                }
            }
            updateButtonStates();
        }

        function confirmPiecePlacement() {
            if (!selectedPiece || selectedPiece.placed) {
                showMessage('No piece selected or piece already placed.', 'error'); return;
            }
            if (!selectedPiece.previewPosition) {
                showMessage('No preview position set for the piece.', 'error'); return;
            }

            const placementResult = checkPlacement(puzzleGrid, selectedPiece.currentShapeCoords, selectedPiece.previewPosition, puzzleSize);
            if (placementResult.fits) {
                placePieceOnGrid(selectedPiece, selectedPiece.previewPosition, placementResult.cellsToOccupy);
                selectedPiece.justPickedUpFromBoard = false;
                const justPlacedId = selectedPiece.id;
                deselectPiece();
                showMessage(`Piece ${justPlacedId} placed successfully!`, 'success');
            } else {
                showMessage(`Cannot place piece here: ${placementResult.reason}. Try moving or rotating.`, 'error');
                updateGhostPreview();
            }
            updateButtonStates();
        }


        function placePieceOnGrid(piece, position, cellsToOccupy) {
            cellsToOccupy.forEach(cell => {
                puzzleGrid[cell.z][cell.y][cell.x] = piece.id;
            });
            piece.placed = true;
            piece.positionOnBoard = { ...position };
            availablePieces = availablePieces.filter(p => p.id !== piece.id);

            renderPuzzleGrid();
            renderPiecePalette();
            checkWinCondition();
        }

        function removePieceFromGrid(piece) {
            if (!piece.placed || !piece.positionOnBoard) return;

             for (const pCoord of piece.currentShapeCoords) {
                const absX = piece.positionOnBoard.x + pCoord[0];
                const absY = piece.positionOnBoard.y + pCoord[1];
                const absZ = piece.positionOnBoard.z + pCoord[2];
                if (absX >= 0 && absX < puzzleSize && absY >= 0 && absY < puzzleSize && absZ >= 0 && absZ < puzzleSize) {
                    if(puzzleGrid[absZ][absY][absX] === piece.id) {
                        puzzleGrid[absZ][absY][absX] = 0;
                    }
                }
            }
            piece.placed = false;
            // piece.positionOnBoard is kept for handleClickOnCell to use for preview. It's nulled if returned/placed.
            if (!availablePieces.find(p => p.id === piece.id)) {
                 availablePieces.push(piece);
                 availablePieces.sort((a,b) => a.id - b.id);
            }
        }


        function selectPieceById(pieceId, element) {
            const pieceToSelect = gamePieces.find(p => p.id === pieceId);
            if (!pieceToSelect) return;
            if (selectedPiece && selectedPiece.id === pieceToSelect.id && !selectedPiece.justPickedUpFromBoard) return; // Avoid re-selecting if not picking up

            selectedPiece = pieceToSelect;
            // justPickedUpFromBoard is set by handleClickOnCell if applicable, otherwise false here means from palette
            if (!selectedPiece.justPickedUpFromBoard) { // if selected from palette
                selectedPiece.justPickedUpFromBoard = false;
                if (!selectedPiece.previewPosition || selectedPiece.placed) { // Reset preview for palette selection if it was placed or null
                     selectedPiece.previewPosition = {x: 0, y: 0, z: 0};
                }
            }


            renderPiecePalette();
            updateGhostPreview();
            updateButtonStates();
            if (selectedPiece && selectedPiece.previewPosition){
                showMessage(`Piece ${selectedPiece.id} selected. Preview at (${selectedPiece.previewPosition.x}, ${selectedPiece.previewPosition.y}, ${selectedPiece.previewPosition.z}).`, 'info');
            } else if (selectedPiece) {
                 showMessage(`Piece ${selectedPiece.id} selected.`, 'info');
            }
        }

        function deselectPiece() {
            if (selectedPiece) {
                selectedPiece.justPickedUpFromBoard = false;
                selectedPiece.previewPosition = null;
            }
            selectedPiece = null;
            clearGhostPreview();
            renderPuzzleGrid();
            renderPiecePalette();
            updateButtonStates();
            if (messageArea.textContent.includes("selected") || messageArea.textContent.includes("Previewing")) {
                showMessage('Piece deselected.', 'info');
            }
        }

        function handleRestartPuzzle() {
            if (gamePieces.length === 0) {
                showMessage('No puzzle loaded to restart.', 'info');
                return;
            }

            gamePieces.forEach(piece => {
                if (piece.placed) {
                    for (const pCoord of piece.currentShapeCoords) {
                        const absX = piece.positionOnBoard.x + pCoord[0];
                        const absY = piece.positionOnBoard.y + pCoord[1];
                        const absZ = piece.positionOnBoard.z + pCoord[2];
                        if (absX >= 0 && absX < puzzleSize && absY >= 0 && absY < puzzleSize && absZ >= 0 && absZ < puzzleSize) {
                            if (puzzleGrid[absZ][absY][absX] === piece.id) {
                                puzzleGrid[absZ][absY][absX] = 0;
                            }
                        }
                    }
                    piece.placed = false;
                    piece.positionOnBoard = null;
                }
                 // Reset piece to its initial optimal preview orientation and coords
                const { optimalShapeCoords, optimalRotationMatrix } = getOptimalPreviewOrientation(piece.shape);
                piece.currentRotationMatrix = optimalRotationMatrix;
                piece.currentShapeCoords = optimalShapeCoords;
                piece.previewPosition = { x: 0, y: 0, z: 0 };
            });

            availablePieces = [...gamePieces];
            if (selectedPiece) {
                 selectedPiece.justPickedUpFromBoard = false;
            }
            selectedPiece = null;

            renderPuzzleGrid();
            clearGhostPreview();
            renderPiecePalette();
            updateButtonStates();
            showMessage('Puzzle restarted. All pieces returned to the tray and reset.', 'success');
        }

        function handleReturnSelectedPieceToTray() {
            if (selectedPiece && selectedPiece.justPickedUpFromBoard) {
                const pieceToReturn = selectedPiece;

                pieceToReturn.placed = false;
                pieceToReturn.positionOnBoard = null;
                pieceToReturn.justPickedUpFromBoard = false;

                // Reset to initial optimal orientation for palette
                const { optimalShapeCoords, optimalRotationMatrix } = getOptimalPreviewOrientation(pieceToReturn.shape);
                pieceToReturn.currentRotationMatrix = optimalRotationMatrix;
                pieceToReturn.currentShapeCoords = optimalShapeCoords;
                pieceToReturn.previewPosition = { x: 0, y: 0, z: 0 };


                if (!availablePieces.find(p => p.id === pieceToReturn.id)) {
                    availablePieces.push(pieceToReturn);
                    availablePieces.sort((a,b) => a.id - b.id);
                }

                deselectPiece();
                showMessage(`Piece ${pieceToReturn.id} returned to tray.`, 'info');
            } else {
                showMessage('No piece picked up from board to return.', 'error');
            }
        }


        function updateButtonStates() {
            const pieceIsSelected = selectedPiece !== null;
            const pieceIsSelectedAndNotPlaced = pieceIsSelected && !selectedPiece.placed;
            const showReturnButton = pieceIsSelected && selectedPiece.justPickedUpFromBoard === true;

            document.getElementById('rotate-x-button').disabled = !pieceIsSelected;
            document.getElementById('rotate-y-button').disabled = !pieceIsSelected;
            document.getElementById('rotate-z-button').disabled = !pieceIsSelected;
            document.getElementById('confirm-placement-button').disabled = !pieceIsSelectedAndNotPlaced;
            document.getElementById('deselect-button').disabled = !pieceIsSelected;

            restartButton.disabled = gamePieces.length === 0;
            if (returnPieceButton) {
                returnPieceButton.style.display = showReturnButton ? 'inline-block' : 'none';
                returnPieceButton.disabled = !showReturnButton;
            }

            const totalVolume = puzzleSize * puzzleSize * puzzleSize;
            let filledCellCount = 0;
            if (gamePieces.length > 0) {
                 for (let z = 0; z < puzzleSize; z++) for (let y = 0; y < puzzleSize; y++) for (let x = 0; x < puzzleSize; x++) {
                    if (puzzleGrid[z][y][x] !== 0) filledCellCount++;
                }
            }
            const gameIsWon = gamePieces.length > 0 && gamePieces.every(p => p.placed) && filledCellCount === totalVolume;

            if (gameIsWon) {
                document.getElementById('rotate-x-button').disabled = true;
                document.getElementById('rotate-y-button').disabled = true;
                document.getElementById('rotate-z-button').disabled = true;
                document.getElementById('confirm-placement-button').disabled = true;
                document.getElementById('deselect-button').disabled = true;
                if(returnPieceButton) returnPieceButton.style.display = 'none';
            }
        }

        // --- Piece Manipulation ---
        function rotateSelectedPiece(axis) {
            if (!selectedPiece || selectedPiece.placed) return; // Can only rotate preview of unplaced piece

            const rotationMatrixStep = getRotationMatrix(axis, Math.PI / 2);
            selectedPiece.currentRotationMatrix = multiplyMatrices(rotationMatrixStep, selectedPiece.currentRotationMatrix);

            // Transform the base shape by the new cumulative rotation matrix
            let newTransformedShape = transformShape(selectedPiece.shape, selectedPiece.currentRotationMatrix);

            // Re-normalize the newTransformedShape so its own minimum coordinates are (0,0,0)
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            newTransformedShape.forEach(p => {
                minX = Math.min(minX, p[0]);
                minY = Math.min(minY, p[1]);
                minZ = Math.min(minZ, p[2]);
            });
            selectedPiece.currentShapeCoords = newTransformedShape.map(p => [p[0] - minX, p[1] - minY, p[2] - minZ]);

            updateGhostPreview();
            renderPiecePalette(); // Update palette representation
            updateButtonStates();
        }

        function handleKeyPress(event) {
            const key = event.key.toLowerCase();
            const pieceMustBeSelectedForKeys = ['x','y','z','enter','t'];

            if (!selectedPiece && pieceMustBeSelectedForKeys.includes(key)) {
                return;
            }
            if (key === 'escape' && !selectedPiece) return;

            let actionTaken = true;
            switch(key) {
                case 'x': if (!document.getElementById('rotate-x-button').disabled) rotateSelectedPiece('x'); else actionTaken = false; break;
                case 'y': if (!document.getElementById('rotate-y-button').disabled) rotateSelectedPiece('y'); else actionTaken = false; break;
                case 'z': if (!document.getElementById('rotate-z-button').disabled) rotateSelectedPiece('z'); else actionTaken = false; break;
                case 'enter': if (!document.getElementById('confirm-placement-button').disabled) confirmPiecePlacement(); else actionTaken = false; break;
                case 'escape': if (!document.getElementById('deselect-button').disabled) deselectPiece(); else actionTaken = false; break;
                case 'r':
                    if (!restartButton.disabled) handleRestartPuzzle();
                    else actionTaken = false;
                    break;
                case 't':
                    if (returnPieceButton.style.display !== 'none' && !returnPieceButton.disabled) {
                        handleReturnSelectedPieceToTray();
                    } else { actionTaken = false; }
                    break;
                default:
                    actionTaken = false;
            }

            if (actionTaken) {
                event.preventDefault();
            }
        }

        // --- Win Condition ---
        function checkWinCondition() {
            let filledCellCount = 0;
            const totalVolume = puzzleSize * puzzleSize * puzzleSize;
            for (let z = 0; z < puzzleSize; z++) {
                for (let y = 0; y < puzzleSize; y++) {
                    for (let x = 0; x < puzzleSize; x++) {
                        if (puzzleGrid[z][y][x] !== 0) {
                            filledCellCount++;
                        }
                    }
                }
            }

            const allPiecesOnBoard = gamePieces.every(p => p.placed);

            if (gamePieces.length > 0 && allPiecesOnBoard && filledCellCount === totalVolume) {
                showMessage(`Congratulations! You solved the ${puzzleSize}x${puzzleSize}x${puzzleSize} puzzle!`, 'success');
                updateButtonStates();
            } else if (gamePieces.length > 0) {
                const remainingPiecesCount = gamePieces.filter(p => !p.placed).length;
                if (allPiecesOnBoard && filledCellCount < totalVolume) {
                     showMessage(`All pieces placed, but the cube is not full. ${filledCellCount}/${totalVolume} cells filled. Check placement.`, 'error');
                } else if (remainingPiecesCount > 0) {
                    showMessage(`${remainingPiecesCount} piece(s) left to place. ${filledCellCount}/${totalVolume} cells filled.`, 'info');
                } else if (!allPiecesOnBoard && filledCellCount === totalVolume) {
                    showMessage(`Cube is full, but not all pieces were used. ${remainingPiecesCount} piece(s) still in tray.`, 'error');
                }
            }
        }

        // --- Utility Functions ---
        function showMessage(msg, type = 'info') {
            messageArea.textContent = msg;
            messageArea.className = 'message-box';
            if (type === 'success') messageArea.classList.add('message-success');
            else if (type === 'error') messageArea.classList.add('message-error');
            else messageArea.classList.add('bg-blue-100', 'text-blue-700');
        }

        // --- Matrix Math for Rotations ---
        function identityMatrix() { return [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ]; }
        function getRotationMatrix(axis, angle) {
            const c = Math.cos(angle); const s = Math.sin(angle);
            if (axis === 'x') return [[1,0,0],[0,c,-s],[0,s,c]];
            if (axis === 'y') return [[c,0,s],[0,1,0],[-s,0,c]];
            if (axis === 'z') return [[c,-s,0],[s,c,0],[0,0,1]];
            return identityMatrix();
        }
        function multiplyMatrices(m1, m2) {
            const r = [[0,0,0],[0,0,0],[0,0,0]];
            for (let i=0;i<3;i++) for (let j=0;j<3;j++) {
                for (let k=0;k<3;k++) r[i][j] += m1[i][k] * m2[k][j];
                r[i][j] = parseFloat(r[i][j].toFixed(9));
                if (Math.abs(r[i][j]) < 1e-9) r[i][j] = 0;
                else if (Math.abs(r[i][j]-1) < 1e-9) r[i][j] = 1;
                else if (Math.abs(r[i][j]+1) < 1e-9) r[i][j] = -1;
            }
            return r;
        }
        function transformPoint(point, matrix) {
            const [x,y,z] = point;
            return [matrix[0][0]*x+matrix[0][1]*y+matrix[0][2]*z, matrix[1][0]*x+matrix[1][1]*y+matrix[1][2]*z, matrix[2][0]*x+matrix[2][1]*y+matrix[2][2]*z].map(v => Math.round(parseFloat(v.toFixed(9))));
        }
        function transformShape(baseShapeCoords, matrix) { return baseShapeCoords.map(p => transformPoint(p, matrix)); }
        function getAllRotations() {
            const matrices = new Set();
            const queue = [identityMatrix()];
            matrices.add(JSON.stringify(identityMatrix()));
            const uniqueMatrices = [identityMatrix()];

            const Rx = getRotationMatrix('x', Math.PI/2);
            const Ry = getRotationMatrix('y', Math.PI/2);

            let head = 0;
            while(head < queue.length && uniqueMatrices.length < 24){ // Should be < 24 for loop condition
                const current = queue[head++];
                // Try multiplying Rx and Ry on both sides to get more combinations from fewer base rotations.
                // Or, more systematically:
                const R_options = [ Rx, Ry ]; // Can add Rz for more direct paths if needed, but Rx, Ry should cover.
                for (const R_op of R_options) {
                    const next_mat_prefix = multiplyMatrices(R_op, current);
                    const next_mat_postfix = multiplyMatrices(current, R_op); // Not standard group generation this way.
                                                                            // Standard is to apply series of fundamental rotations.

                    let mats_to_check = [next_mat_prefix];
                    // If just using Rx, Ry on current, it's simpler:
                    // const next_rots = [multiplyMatrices(Rx, current), multiplyMatrices(Ry, current)];

                    for(const next_mat of mats_to_check){
                        const mat_str = JSON.stringify(next_mat);
                        if(!matrices.has(mat_str)){
                            matrices.add(mat_str);
                            uniqueMatrices.push(next_mat);
                            queue.push(next_mat);
                            if(uniqueMatrices.length >= 24) break;
                        }
                    }
                    if(uniqueMatrices.length >= 24) break;
                }
            }

            // Fallback / alternative generation if the above queue method is incomplete or slow
            if (uniqueMatrices.length < 24) {
                console.warn(`getAllRotations queue method produced ${uniqueMatrices.length} matrices. Trying fallback.`);
                uniqueMatrices.length = 0; // Clear array
                matrices.clear(); // Clear set
                const R_Set_fallback = new Set();
                const R_Array_fallback = [];

                const I = identityMatrix();
                const Rx90 = getRotationMatrix('x', Math.PI/2);
                const Ry90 = getRotationMatrix('y', Math.PI/2);
                const Rz90 = getRotationMatrix('z', Math.PI/2); // Rz might be needed for systematic generation

                let current_orientation = I;
                // Generate 24 unique rotation matrices
                // One way: apply y rotations, then for each, apply x rotations.
                // This covers orientations like looking from 6 faces (±x, ±y, ±z up)
                // And for each of those, 4 rotations around that 'up' axis. (6 * 4 = 24)
                for (let i = 0; i < 4; i++) { // Rotations about Y axis (like turning head left/right)
                    let m_y_rot = current_orientation;
                    for (let j = 0; j < 4; j++) { // Rotations about X axis (like nodding head up/down)
                        const mat_str = JSON.stringify(m_y_rot);
                        if (!R_Set_fallback.has(mat_str)) {
                            R_Set_fallback.add(mat_str);
                            R_Array_fallback.push(m_y_rot);
                        }
                        // Also consider rotations around the Z axis for each X/Y face
                        let m_z_rot = m_y_rot;
                        for (let k=0; k<4; k++){
                             const mat_str_z = JSON.stringify(m_z_rot);
                             if (!R_Set_fallback.has(mat_str_z)) {
                                R_Set_fallback.add(mat_str_z);
                                R_Array_fallback.push(m_z_rot);
                            }
                            m_z_rot = multiplyMatrices(Rz90, m_z_rot);
                        }
                        m_y_rot = multiplyMatrices(Rx90, m_y_rot);
                    }
                    current_orientation = multiplyMatrices(Ry90, current_orientation);
                }
                 // Ensure only unique matrices are returned, capped at 24
                const final_matrices = [];
                const seen_final = new Set();
                for (const mat of R_Array_fallback) {
                    const s = JSON.stringify(mat);
                    if (!seen_final.has(s) && final_matrices.length < 24) {
                        seen_final.add(s);
                        final_matrices.push(mat);
                    }
                }
                if (final_matrices.length < 24) console.warn(`Fallback getAllRotations produced ${final_matrices.length} matrices.`);
                return final_matrices.length > 0 ? final_matrices : [identityMatrix()]; // Ensure at least identity
            }
            return uniqueMatrices;
        }

    </script>
</body>
</html>
